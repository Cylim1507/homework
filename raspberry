import pymysql
import serial
from datetime import datetime
import time

# --- Configuration ---
DB_HOST = "localhost"
DB_USER = "kali"
DB_PASSWORD = ""
DB_NAME = "assignment1"

SERIAL_PORT = '/dev/ttyS0'
BAUD_RATE = 9600
PRESSURE_THRESHOLD = 100  # Adjust based on your sensor's empty value
EMPTY_TIMEOUT = 10        # seconds

# --- Database logging function ---
def log_to_db(uid, status):
    try:
        connection = pymysql.connect(
            host=DB_HOST,
            user=DB_USER,
            password=DB_PASSWORD,
            database=DB_NAME
        )

        with connection.cursor() as cursor:
            sql = "INSERT INTO logs (uid, status, timestamp) VALUES (%s, %s, %s)"
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            cursor.execute(sql, (uid, status, timestamp))

        connection.commit()
        print(f"‚úÖ Logged: UID={uid}, STATUS={status}, TIME={timestamp}")

    except pymysql.MySQLError as e:
        print(f"‚ùå MySQL Error: {e}")

    finally:
        if connection:
            connection.close()

# --- Main loop ---
def main():
    try:
        print("üîå Connecting to serial...")
        ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
        
        # Soft reset Arduino
        ser.setDTR(False)
        time.sleep(1)
        ser.flushInput()
        ser.setDTR(True)
        time.sleep(2)
        print("üì° Listening for RFID scans...")

        last_activity_time = time.time()
        empty_start_time = None
        door_unlocked = False

        while True:
            line = ser.readline().decode('utf-8').strip()
            current_time = time.time()

            if line.startswith("LOG:"):
                try:
                    parts = line.split(",")
                    uid = parts[0][4:].strip()
                    status = parts[1].strip()

                    log_to_db(uid, status)

                    # üîÑ Update state
                    last_activity_time = current_time
                    door_unlocked = (status == "UNLOCKED")
                    empty_start_time = None  # Reset pressure tracking on new scan

                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to parse line: {line} ‚Üí {e}")

            elif line.startswith("PRESSURE:"):
                try:
                    pressure = int(line.split(":")[1].strip())
                    print(f"üìâ Pressure reading: {pressure}")

                    if door_unlocked and pressure < PRESSURE_THRESHOLD:
                        if empty_start_time is None:
                            empty_start_time = current_time
                            print("üõèÔ∏è Pad is empty while unlocked ‚Äî started timer")
                        elif current_time - empty_start_time >= EMPTY_TIMEOUT:
                            print("üö® Pad is empty for 10 seconds while unlocked ‚Üí TRIGGER BUZZER!")
                            empty_start_time = None  # Prevent repeated alerts
                    else:
                        if empty_start_time is not None:
                            print("üü¢ Pad no longer empty or door locked ‚Üí reset timer")
                        empty_start_time = None

                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to parse pressure line: {line} ‚Üí {e}")

            # üîÑ Old rule: timeout after unlock
            elif door_unlocked and (current_time - last_activity_time >= 15):
                print("‚è∞ No RFID activity for 15 seconds after UNLOCK ‚Üí Trigger buzzer!")
                door_unlocked = False
                empty_start_time = None

            time.sleep(0.1)

    except serial.SerialException as e:
        print(f"‚ùå Serial port error: {e}")

    except KeyboardInterrupt:
        print("\nüõë Program terminated by user.")

if __name__ == "__main__":
    main()
